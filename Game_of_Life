

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
N = 20
pause = False;
ON = 255
OFF = 0
Cells = [True, False]



def onClick(event):
    global pause
    if pause == False:
        pause = True
    else:
        pause=False

class Rules:
    def rule(self, grid, i,j,newgrid,c):  # if alive

                if grid[i][j]==True:
                    if c < 2 or c > 3:
                        newgrid[i, j]= False
                else:
                    if c == 3:
                        newgrid[i, j] = True

    def neighbourscounter(self,grid,i,j):  # Return the number of Neighbours alive#
        c = 0

        try:
            if grid[ i- 1][ j- 1]==True:
                c += 1
        except Exception:
            pass

        try:
            if grid[i- 1][j]==True:
                c += 1
        except Exception:
            pass
        try:
            if grid[i][j-1]==True:
                c += 1
        except Exception:
            pass
        try:
            if grid[i + 1][j- 1]==True:
                c += 1
        except Exception:
            pass
        try:
            if grid[i + 1][j]==True:
                c += 1
        except Exception:
            pass
        try:
            if grid[i - 1][j + 1]==True:
                c+=1
        except Exception:
            pass
        try:
            if grid[i][j + 1]==True:
                c += 1
        except Exception:
            pass
        try:
            if grid[i+ 1][j + 1]==True:
                c += 1
        except Exception:
            pass

        return c


rule_ = Rules()

x = raw_input('Set an action or Pattern - Enter or rng for random cells distribution')
if x == '' or x == 'rng':
    grid = np.random.choice(Cells, N * N, p=[0.2, 0.8]).reshape(N, N)
else:
    print('Not implemented yed!')

# populate grid with random on/off - more off than on
def update(data):
    if pause == False:
        global grid
        newGrid = grid.copy()
        for i in range(N):
            for j in range(N):
                total = Rules.neighbourscounter(rule_,grid,i,j)
                Rules.rule( rule_,grid,i,j,newGrid,total)
        mat.set_data(newGrid)
        grid = newGrid
        return [mat]


# set up animation
fig, ax = plt.subplots()

fig.canvas.mpl_connect('button_press_event', onClick)

mat = ax.matshow(grid)
ani = animation.FuncAnimation(fig, update,frames=60 ,interval=600)
plt.show()

